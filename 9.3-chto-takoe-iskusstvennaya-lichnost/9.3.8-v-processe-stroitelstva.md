# 9.3.8 В процессе строительства

Давайте рассмотрим все части, которые мы должны собрать воедино, чтобы сделать нашу личность робота:

* Симуляция 
* Моделирование \(стохастическое или случайное\) Монте-Карло 
* Конечный автомат эмоций нашего робота 
* Восприятие конечного автомата человеческих эмоций 
* Биография нашего робота \(список внутренних фактов о роботе\) 
* Фреймворк разговорной системы ELIZA 
* Контекст - способность вспоминать и возвращать факты и «заполнять пробелы»

В следующих нескольких разделах я представлю код, который я добавил Альберту, чтобы способствовать его искусственной личности. Многое из этого будет содержаться в файлах скриптов, которые предоставляют правила и шаблоны речи Tinman. Там также будут функции в виде кода для его движка эмоций, модели человеческих эмоций и игрового движка.

Давайте начнем.

Мне нужно было добавить несколько новых функций в язык скриптов, используемый ELIZA. Во-первых, я добавил контекст нашего робота, который заменит ELIZA, терапевта.

Во-первых, у нас есть вступительные слова, когда мы запускаем интерактивный режим разговора Tinman, говоря: _«Hey, Albert»_ \(или иначе, если вы дали ему другое имя\)» - слово пробуждения Mycroft, а потом просто _«Hello»_.

Робот Альберт получил свое имя от Альберта, принца-консорта королевы Виктории, так как он был знаменит тем, что потрясающе заботился о своих детях. Все девять его детей дожили до зрелого возраста, что является редкостью в викторианскую эпоху, и у него было 42 внука. Он был известен по второму имени – его фактическое первое имя было Франц.

Робот отвечает «начальной» фразой, что отмечено тегом перед двоеточием. У нас также есть здесь заключительная фраза. Вы можете прописать столько фраз, сколько захотите, и компьютер случайным образом выберет одну из них. Эти правила входят в файл, который я назвал `AlbertPersonality.txt`, который начался как копия исходного файла скрипта `doctor.txt` с ELIZA:

```text
initial: Hello. My name is Albert the Tinman Robot. 
initial: Hello. I am Tinman the Robot, but you can call me Albert. 
initial: Hello. Nice to meet you. Call me Albert. 
final: Goodbye. Thank you for talking to me. 
final: Goodbye. It was nice to talk to you. final: Goodbye. I need to get back to my tasks. 
quit: bye 
quit: goodbye
```

Я добавил несколько замен слов в том случае, если пользователь назовёт робота по имени, а не _you_. Это просто заменяет _you_ на то, как вы назвали робота. Я также прописал синонимы для альтернативных версий имени робота, так что вы можете назвать его _robot_ или _bot,_ а также _Albert_, _Bert_, или даже _Bertie_.

Правило с `pre`: перед ним всё заменяется до любой другой обработки. Согласно первому правилу, если слово _robot_ появляется в предложении, как в, например, _Robot, how old are you?_ программа удаляет _robot_ и заменяет _you_, чтобы сделать синтаксический анализ консистентным. Мы также меняем все заглавные буквы на строчные, поэтому в правилах нет заглавных букв. Правило с `synon`: заменяет любое из перечисленных слов первым данным словом:

```text
pre: robot you 
pre: albert you 
… 
synon: you robot albert bert bertie bot 
synon: belief feel think believe wish
```

Следующее, что нам нужно было сделать, это создать вопросы, которые будет задавать робот, чтобы получить информацию. Программа будет автоматически _собирать_ эти данные в любом из ключевых слов, появление которых мы определим в предложении. Вот определение правил о том, как задавать вопросы:

```text
questions: 
reasmb: What is your name? <assert name>
reasmb: What can I call you? <assert name>
reasmb: How old are you? <assert old>
reasmb: How are you feeling today <assert feeling>
```

Мы создаем новый флаг для вопросов, которые добавим в наш файл скрипта. Каждая строка представляет один вопрос, но мы можем его задать по-разному или в разных формах. Программа выберет один вариант вопроса случайным образом, и она решает, какой вопрос задать, основываясь на относительном приоритете, который мы присвоим вопросам. Ключевое слово `assert` с символами `<>` вокруг него - еще один новый флаг, который я добавил, чтобы дать сигнал контекстной памяти, которую мы создали, о контексте задавания какого-то вопроса, и следующее утверждение, вероятно, ответ:

```text
datum: name 
decomp * my name is * 
decomp I am *
decomp call me * 
decomp <name> * # we are in the name context
reasmb: Hello (1). Nice to meet you 
reasmb: Hi (1). 
reasmb: Your name is (1), right?
reasmb: Thank you for telling me your name, (1) 
store: <name> (1) 
decomp * my name is * 
reasmb: Hello (2). Nice to meet you.[welcome][happy] 
store:<name> (2)
```

Я создал новую структуру данных, которую назвал `datum`, единственное число от **data**. Она представляет собой некоторую информацию, которую мы хотим, чтобы робот спросил. Мы даем datum имя - `name,` поскольку мы хотим, чтобы робот спросил имя того, с кем он разговаривает. Теги `decomp` \(декомпозиция\) - это шаблоны предложений, в которых пользователь может сказать своё имя. Символ`*` _обозначает любую фразу. Так что, если человек скажет: «Hello. My name is Fred Rodgers», робот будет называть его Фредом Роджерсом. Если человек скажет: «Call me Ishmael» по какой-то неизвестной причине, тогда робот будет использовать это. Мы должны пересобрать ответную фразу согласно правилам reasmb. Число \(1\) относится к первой_  появившейся фразе. Если пользователь говорит: _«I am John»_, то тогда, когда мы используем правила пересборки, \(1\) будет заменено на _John_. Далее робот выберет одну из предложенных фраз случайным образом, например: _«Your name is John, right?»_.

Я добавил еще один новый тег, чтобы робот мог использовать область контекстной памяти для выполнения двух функции. Мы можем объявить контекстную тему в момент задавания вопроса, что мы сделаем разделом позже. Например, когда мы спрашиваем пользователя: _«What is your name?»_, мы хотим, чтобы робот знал о том, что последующий ответ будет в контексте этого вопроса. Вполне допустима ситуация, когда робот спросит: _«Who are you?»_ и пользователь сразу же ответит _Julia_ без других слов в предложении. Как программа узнает, что делать с Джулией? Ответ - контекстный флаг, обособленный скобкой `<>`. Мы читаем правило декомпозиции `decomp <name> *` таким образом: если вы находитесь в контексте запроса имени и получаете ответ без ключевых слов, то считаете все, что получите, в качестве ответа.

Теги эмоций отмечены скобками, например \[happy\] или \[sad\]. Это продвинет дальше эмоции робота или восприятие робота человеческих эмоций, в зависимости от того, было утверждение сказано человеком или роботом. Тегов эмоций, связанных с утверждением, может быть больше одного.

Вот правила прослушивания ответа на вопрос о `age`:

```text
datum: age 
decomp <age> * I am * years old 
decomp <age> * I am % # integer 
reasmb: You are (2) years old? 
reasmb: (2) years old! 
decomp <age> * 
reasmb: You are (1) years old? 
reasmb: (1) years old! 
store: <age> (1)
```

Последняя строка `store:` это команда, сообщающая компьютеру, что это ответ на вопрос, и его требуется сохранить в словаре вместе с названием.

Далее, давайте рассмотрим пример взаимодействия в совокупности с какими-либо эмоциями, чтобы понять, как мы будем использовать движок эмоций для контроля над тем, что говорит робот. Этот набор правил активируется, когда пользователь говорит роботу: _«How are you?»_

```text
key: feeling
 decomp: how are you feeling
 decomp: how are you
 decomp: hows it hanging
 decomp: how are you today
 reasmb: <happy> I'm doing well. How are you? <assert feeling>
 reasmb: <sad> I am feeling sad. How are you? <assert feeling>
 reasmb: <curious> I am curious about my surroundings
 reasmb: <friend> I am feeling friendly today
 reasmb: <welcome> I am in a welcoming mood today, my friend
 reasmb: <frust> I am a bit frustrated, to tell you the truth
 reasmb: <frust> I am feeling a bit frustrated
 reasmb: <strange> I am having relationship problems
 reasmb: <distant> None of my friends have come to visit
 reasmb: <tired> goto tired
```

Мы будем помещать эмоции робота в контекстную память, для того чтобы программа обработки скрипта могла иметь к ним доступ. Мы рассматриваем эмоцию - в целях диалога – как часть контекста, о котором мы говорим, что я считаю разумным подходом к работе с эмоциями. Каждая эмоция имеет тег или имя в словаре контекстной памяти. Если преобладающая эмоция в роботе happy, то робот устанавливает контекст happy в контекстную память. Затем база правил будет использовать тег контекста, чтобы определить, какую фразу использовать для ответа на «how are you feeling?» Мы также можем задать дополнительный вопрос. Взгляните на правило для &lt;happy&gt;. Робот отвечает: «I’m doing well. How are you?», а затем устанавливает контекст feeling, чтобы движок знал, что мы задали вопрос о чувствах. Наконец, последняя строка относится к эмоции &lt;tired&gt;. Если робот чувствует себя уставшим, то мы перескакиваем в отдельный раздел, где робот говорит об усталости. Мы делаем это отдельным действием, потому что нам нужно вызывать это из нескольких участков, что иллюстрирует полезность такого подхода к речи на основе правил. Я не хочу даже представлять, сколько C или C ++ SLOC \(количества строк кода\) потребуется, чтобы создать все эти правила для каждой строки диалога.

